<!DOCTYPE html>
<html lang="he">
<head>
<meta charset="UTF-8">
<title>–ü–æ–º–æ—â–Ω–∏–∫: –†—É—Å—Å–∫–∏–π ‚Üí –ò–≤—Ä–∏—Ç / –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ</title>

<!-- Bootstrap -->
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">

<style>
body {
  padding: 25px;
  background: #f8f9fa;
}
textarea {
  resize: vertical;
  min-height: 150px;
  font-size: 18px;
}
#result {
  white-space: pre-wrap;
  min-height: 150px;
  font-size: 18px;
  background: white;
}
.card {
  border-radius: 12px;
  box-shadow: 0 4px 10px rgba(0,0,0,0.08);
}
button {
  font-size: 18px !important;
}
#copyAlert {
  display: none;
}
.spinner {
  display: none;
}
#recordingIndicator {
  display: none;
}
.btn-recording {
  transform: scale(0.98);
  box-shadow: inset 0 3px 5px rgba(0,0,0,0.3) !important;
}
.recording-pulse {
  animation: recordingPulse 1.5s ease-in-out infinite;
}
@keyframes recordingPulse {
  0%, 100% {
    opacity: 1;
    transform: scale(1);
  }
  50% {
    opacity: 0.7;
    transform: scale(1.05);
  }
}
.recording-dot {
  display: inline-block;
  animation: recordingDot 1s linear infinite;
}
@keyframes recordingDot {
  0%, 20% { opacity: 1; }
  50% { opacity: 0.3; }
  80%, 100% { opacity: 1; }
}
</style>
</head>
<body>

<div class="container">

  <div class="card p-4 mb-4">
    <h2 class="mb-3 text-center">–ü–æ–º–æ—â–Ω–∏–∫: –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∏ –ø–µ—Ä–µ–≤–æ–¥</h2>

    <!-- –†–ï–ñ–ò–ú -->
    <div class="mb-3">
      <label class="form-label fw-bold">–†–µ–∂–∏–º:</label>
      <select id="mode" class="form-select">
        <option value="fix">–ò—Å–ø—Ä–∞–≤–∏—Ç—å —Ç–µ–∫—Å—Ç –Ω–∞ –∏–≤—Ä–∏—Ç–µ</option>
        <option value="translate">–†—É—Å—Å–∫–∏–π ‚Üí –ò–≤—Ä–∏—Ç</option>
        <option value="voice">–ì–æ–ª–æ—Å ‚Üí –ò–≤—Ä–∏—Ç</option>
      </select>
    </div>

    <!-- –í–´–ë–û–† –Ø–ó–´–ö–ê –î–õ–Ø –ì–û–õ–û–°–ê -->
    <div class="mb-3">
      <label class="form-label fw-bold">–Ø–∑—ã–∫ –≥–æ–ª–æ—Å–æ–≤–æ–≥–æ –≤–≤–æ–¥–∞:</label>
      <select id="voiceLang" class="form-select">
        <option value="auto">–ê–≤—Ç–æ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ</option>
        <option value="ru-RU">–†—É—Å—Å–∫–∏–π</option>
        <option value="he-IL">–ò–≤—Ä–∏—Ç</option>
      </select>
    </div>

    <!-- –¢–ï–ö–°–¢–û–í–´–ô –í–í–û–î -->
    <div class="mb-3">
      <textarea id="inputText" class="form-control" placeholder="–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç..."></textarea>
    </div>

    <!-- –ö–ù–û–ü–ö–ò -->
    <div class="d-flex gap-2 mb-3">
      <button class="btn btn-primary flex-fill" onclick="processText()">–û—Ç–ø—Ä–∞–≤–∏—Ç—å</button>
      <button class="btn btn-secondary flex-fill" id="voiceBtn" 
              onmousedown="startVoiceRecording()" 
              onmouseup="stopVoiceRecording()" 
              onmouseleave="stopVoiceRecording()"
              ontouchstart="startVoiceRecording()" 
              ontouchend="stopVoiceRecording()">üé§ –£–¥–µ—Ä–∂–∏–≤–∞–π—Ç–µ –¥–ª—è –∑–∞–ø–∏—Å–∏</button>
      <button class="btn btn-outline-danger" onclick="clearInput()">üóëÔ∏è –û—á–∏—Å—Ç–∏—Ç—å</button>
    </div>

    <!-- –°–ü–ò–ù–ù–ï–† -->
    <div class="text-center spinner" id="loader">
      <div class="spinner-border text-primary" role="status"></div>
      <p>–û–±—Ä–∞–±–æ—Ç–∫–∞...</p>
    </div>

    <!-- –ò–ù–î–ò–ö–ê–¢–û–† –ó–ê–ü–ò–°–ò -->
    <div class="text-center" id="recordingIndicator">
      <div class="alert alert-danger d-inline-block recording-pulse" role="alert">
        <span class="recording-dot">üî¥</span> <strong>–ó–ê–ü–ò–°–¨...</strong> –û—Ç–ø—É—Å—Ç–∏—Ç–µ –∫–Ω–æ–ø–∫—É –¥–ª—è –æ—Å—Ç–∞–Ω–æ–≤–∫–∏
        <div class="spinner-border spinner-border-sm text-danger ms-2" role="status" aria-label="Recording">
          <span class="visually-hidden">Recording...</span>
        </div>
      </div>
    </div>

    <!-- –†–ï–ó–£–õ–¨–¢–ê–¢ -->
    <h4 class="mt-3">–†–µ–∑—É–ª—å—Ç–∞—Ç:</h4>
    <div id="result" class="form-control mb-3"></div>

    <!-- –ö–û–ü–ò–†–û–í–ê–ù–ò–ï -->
    <button class="btn btn-success" onclick="copyResult()">–°–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å</button>
    <div id="copyAlert" class="text-success mt-2 fw-bold">‚úî –°–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–æ!</div>

  </div>

</div>


<!-- JS -->
<script>
// ------------------------------
// 1. Hebrew text correction
// ------------------------------
async function fixHebrew(text) {
  try {
    // Try LanguageTool API
    const response = await fetch("https://api.languagetool.org/v2/check", {
      method: "POST",
      headers: { "Content-Type": "application/x-www-form-urlencoded" },
      body: "text=" + encodeURIComponent(text) + "&language=he"
    });

    if (!response.ok) {
      throw new Error(`LanguageTool API returned ${response.status}`);
    }

    const data = await response.json();
    let corrected = text;

    // Apply corrections in reverse order to maintain text positions
    data.matches.reverse().forEach(match => {
      if (match.replacements && match.replacements.length > 0) {
        corrected =
          corrected.slice(0, match.offset) +
          match.replacements[0].value +
          corrected.slice(match.offset + match.length);
      }
    });

    return corrected;
    
  } catch (err) {
    console.error("Hebrew correction failed:", err);
    
    // Fallback: Basic Hebrew text cleanup
    return basicHebrewCleanup(text);
  }
}

// Basic Hebrew text cleanup function
function basicHebrewCleanup(text) {
  // Remove extra spaces and fix common issues
  let cleaned = text
    .replace(/\s+/g, ' ')  // Multiple spaces to single space
    .replace(/^\s+|\s+$/g, '')  // Trim start and end
    .replace(/([\.!?])\s*([◊ê-◊™])/g, '$1 $2')  // Space after punctuation
    .replace(/([◊ê-◊™])\s*([\.!?])/g, '$1$2');  // No space before punctuation
  
  // Basic punctuation fixes for Hebrew
  cleaned = cleaned
    .replace(/\?\?+/g, '?')  // Multiple question marks
    .replace(/!!+/g, '!')    // Multiple exclamation marks
    .replace(/\.\.+/g, '...')  // Multiple dots to ellipsis
    .replace(/,,+/g, ',');   // Multiple commas
  
  return cleaned;
}


// ------------------------------
// 2. Translation RU ‚Üí HE using MyMemory API
// ------------------------------
async function translateRuHe(text) {
  try {
    // MyMemory API - free translation service that allows CORS
    const url = `https://api.mymemory.translated.net/get?q=${encodeURIComponent(text)}&langpair=ru|he`;
    
    const response = await fetch(url, {
      method: "GET",
      headers: {
        "Accept": "application/json"
      }
    });

    if (!response.ok) {
      throw new Error(`Translation service returned ${response.status}`);
    }

    const data = await response.json();
    
    if (data && data.responseData && data.responseData.translatedText) {
      return data.responseData.translatedText;
    } else {
      throw new Error("Invalid response format from translation service");
    }
    
  } catch (err) {
    console.error("Translation failed:", err);
    
    // Fallback: Basic transliteration for common Russian-Hebrew words
    const fallbackTranslation = fallbackRuToHe(text);
    if (fallbackTranslation !== text) {
      return fallbackTranslation + " (–±–∞–∑–æ–≤—ã–π –ø–µ—Ä–µ–≤–æ–¥)";
    }
    
    throw new Error("–ü–µ—Ä–µ–≤–æ–¥ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ –∏–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –¥—Ä—É–≥–æ–π —Å–µ—Ä–≤–∏—Å.");
  }
}

// ------------------------------
// 3. Fallback translation for common words
// ------------------------------
function fallbackRuToHe(text) {
  const commonWords = {
    '–ø—Ä–∏–≤–µ—Ç': '◊©◊ú◊ï◊ù',
    '—Å–ø–∞—Å–∏–±–æ': '◊™◊ï◊ì◊î',
    '–ø–æ–∂–∞–ª—É–π—Å—Ç–∞': '◊ë◊ë◊ß◊©◊î',
    '–¥–∞': '◊õ◊ü',
    '–Ω–µ—Ç': '◊ú◊ê',
    '—Ö–æ—Ä–æ—à–æ': '◊ò◊ï◊ë',
    '–ø–ª–æ—Ö–æ': '◊®◊¢',
    '–≤–æ–¥–∞': '◊û◊ô◊ù',
    '–¥–æ–º': '◊ë◊ô◊™',
    '–º–∞–º–∞': '◊ê◊û◊ê',
    '–ø–∞–ø–∞': '◊ê◊ë◊ê',
    '—Å—ã–Ω': '◊ë◊ü',
    '–¥–æ—á—å': '◊ë◊™',
    '–±—Ä–∞—Ç': '◊ê◊ó',
    '—Å–µ—Å—Ç—Ä–∞': '◊ê◊ó◊ï◊™',
    '–¥—Ä—É–≥': '◊ó◊ë◊®',
    '–ø–æ–¥—Ä—É–≥–∞': '◊ó◊ë◊®◊î',
    '—Ä–∞–±–æ—Ç–∞': '◊¢◊ë◊ï◊ì◊î',
    '—à–∫–æ–ª–∞': '◊ë◊ô◊™ ◊°◊§◊®',
    '—É–Ω–∏–≤–µ—Ä—Å–∏—Ç–µ—Ç': '◊ê◊ï◊†◊ô◊ë◊®◊°◊ô◊ò◊î',
    '–≤—Ä–µ–º—è': '◊ñ◊û◊ü',
    '–¥–µ–Ω—å': '◊ô◊ï◊ù',
    '–Ω–æ—á—å': '◊ú◊ô◊ú◊î',
    '—É—Ç—Ä–æ': '◊ë◊ß◊®',
    '–≤–µ—á–µ—Ä': '◊¢◊®◊ë',
    '–∫—Ä–∞—Å–∏–≤—ã–π': '◊ô◊§◊î',
    '–±–æ–ª—å—à–æ–π': '◊í◊ì◊ï◊ú',
    '–º–∞–ª–µ–Ω—å–∫–∏–π': '◊ß◊ò◊ü',
    '–Ω–æ–≤—ã–π': '◊ó◊ì◊©',
    '—Å—Ç–∞—Ä—ã–π': '◊ô◊©◊ü',
    '–∫—Ä–∞—Å–Ω—ã–π': '◊ê◊ì◊ï◊ù',
    '—Å–∏–Ω–∏–π': '◊õ◊ó◊ï◊ú',
    '–∑–µ–ª–µ–Ω—ã–π': '◊ô◊®◊ï◊ß',
    '–∂–µ–ª—Ç—ã–π': '◊¶◊î◊ï◊ë',
    '—á–µ—Ä–Ω—ã–π': '◊©◊ó◊ï◊®',
    '–±–µ–ª—ã–π': '◊ú◊ë◊ü'
  };
  
  let translated = text.toLowerCase();
  
  // Replace whole words only
  for (const [russian, hebrew] of Object.entries(commonWords)) {
    const regex = new RegExp(`\\b${russian}\\b`, 'gi');
    translated = translated.replace(regex, hebrew);
  }
  
  return translated;
}


// ------------------------------
// 4. –ì–æ–ª–æ—Å–æ–≤–æ–π –≤–≤–æ–¥ (RU/HE + –∞–≤—Ç–æ) - Press and Hold
// ------------------------------
let recognition = null;
let isRecording = false;

function detectLanguage(text) {
  // –æ—á–µ–Ω—å –ø—Ä–æ—Å—Ç–∞—è —ç–≤—Ä–∏—Å—Ç–∏–∫–∞
  const hebrew = /[\u0590-\u05FF]/;
  if (hebrew.test(text)) return "he-IL";
  return "ru-RU";
}

function formatSpeechText(text) {
  // Clean up the speech text and add proper punctuation
  let formatted = text.trim();
  
  // Convert common speech commands to punctuation (Russian)
  const russianCommands = {
    '—Ç–æ—á–∫–∞': '.',
    '–∑–∞–ø—è—Ç–∞—è': ',', 
    '–≤–æ—Å–∫–ª–∏—Ü–∞—Ç–µ–ª—å–Ω—ã–π –∑–Ω–∞–∫': '!',
    '–≤–æ–ø—Ä–æ—Å–∏—Ç–µ–ª—å–Ω—ã–π –∑–Ω–∞–∫': '?',
    '–¥–≤–æ–µ—Ç–æ—á–∏–µ': ':',
    '—Ç–æ—á–∫–∞ —Å –∑–∞–ø—è—Ç–æ–π': ';',
    '—Ç–∏—Ä–µ': ' - ',
    '–∫–∞–≤—ã—á–∫–∏': '"',
    '–æ—Ç–∫—Ä—ã—Ç—å –∫–∞–≤—ã—á–∫–∏': '"',
    '–∑–∞–∫—Ä—ã—Ç—å –∫–∞–≤—ã—á–∫–∏': '"',
    '–Ω–æ–≤–∞—è —Å—Ç—Ä–æ–∫–∞': '\n',
    '–∞–±–∑–∞—Ü': '\n\n'
  };
  
  // Convert common speech commands to punctuation (Hebrew)
  const hebrewCommands = {
    '◊†◊ß◊ï◊ì◊î': '.',
    '◊§◊°◊ô◊ß': ',',
    '◊°◊ô◊û◊ü ◊ß◊®◊ô◊ê◊î': '!', 
    '◊°◊ô◊û◊ü ◊©◊ê◊ú◊î': '?',
    '◊†◊ß◊ï◊ì◊ï◊™◊ô◊ô◊ù': ':',
    '◊†◊ß◊ï◊ì◊î ◊ï◊§◊°◊ô◊ß': ';',
    '◊û◊ß◊£': ' - ',
    '◊û◊®◊õ◊ê◊ï◊™': '"',
    '◊©◊ï◊®◊î ◊ó◊ì◊©◊î': '\n'
  };
  
  // Apply Russian commands
  for (const [command, punctuation] of Object.entries(russianCommands)) {
    const regex = new RegExp(`\\b${command}\\b`, 'gi');
    formatted = formatted.replace(regex, punctuation);
  }
  
  // Apply Hebrew commands  
  for (const [command, punctuation] of Object.entries(hebrewCommands)) {
    const regex = new RegExp(`\\b${command}\\b`, 'gi');
    formatted = formatted.replace(regex, punctuation);
  }
  
  // Capitalize first letter of sentences
  formatted = formatted.replace(/(^|[.!?]\s+)([a-z–∞-—è])/g, (match, prefix, letter) => {
    return prefix + letter.toUpperCase();
  });
  
  // Clean up extra spaces
  formatted = formatted.replace(/\s+/g, ' ').trim();
  
  // Auto-add period at the end if missing punctuation
  const endsWithPunctuation = /[.!?„ÄÇÔºÅÔºü]$/.test(formatted);
  if (formatted.length > 0 && !endsWithPunctuation) {
    // Only add period if it looks like a complete sentence (more than 3 words)
    const wordCount = formatted.split(/\s+/).length;
    if (wordCount >= 3) {
      formatted += '.';
    }
  }
  
  return formatted;
}

function startVoiceRecording() {
  if (isRecording) return;
  
  if (!("webkitSpeechRecognition" in window) && !("SpeechRecognition" in window)) {
    alert("–í–∞—à –±—Ä–∞—É–∑–µ—Ä –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –≥–æ–ª–æ—Å–æ–≤–æ–π –≤–≤–æ–¥.");
    return;
  }

  isRecording = true;
  const voiceBtn = document.getElementById("voiceBtn");
  const indicator = document.getElementById("recordingIndicator");
  
  // Update UI with pressed state and animation
  voiceBtn.classList.remove("btn-secondary");
  voiceBtn.classList.add("btn-danger", "btn-recording", "recording-pulse");
  voiceBtn.innerHTML = '<span class="recording-dot">üî¥</span> –ó–∞–ø–∏—Å—å...';
  indicator.style.display = "block";

  // Setup recognition
  recognition = new (window.SpeechRecognition || window.webkitSpeechRecognition)();
  
  const selected = document.getElementById("voiceLang").value;
  recognition.lang = selected === "auto" ? "ru-RU" : selected;
  recognition.continuous = true;
  recognition.interimResults = true;
  
  // Enable punctuation and formatting
  if (recognition.webkitSpeechRecognition) {
    recognition.webkitGrammar = true;
  }
  
  // Additional settings for better punctuation support
  try {
    recognition.maxAlternatives = 1;
    recognition.serviceURI = recognition.serviceURI || '';
  } catch (e) {
    // Ignore if not supported
  }

  recognition.onresult = event => {
    let finalTranscript = '';
    
    for (let i = event.resultIndex; i < event.results.length; i++) {
      if (event.results[i].isFinal) {
        finalTranscript += event.results[i][0].transcript;
      }
    }
    
    if (finalTranscript) {
      // Clean and format the transcript before inserting
      let formattedText = formatSpeechText(finalTranscript);
      
      const inputField = document.getElementById("inputText");
      const currentText = inputField.value.trim();
      
      // Smart spacing: add space if there's already text and it doesn't end with punctuation
      let separator = "";
      if (currentText) {
        const lastChar = currentText.slice(-1);
        const punctuation = /[.!?„ÄÇÔºÅÔºü]/;
        separator = punctuation.test(lastChar) ? " " : " ";
      }
      
      inputField.value = currentText + separator + formattedText;
    }
  };

  recognition.onerror = event => {
    console.error("Speech recognition error:", event.error);
    stopVoiceRecording();
  };

  recognition.start();
}

function stopVoiceRecording() {
  if (!isRecording) return;
  
  isRecording = false;
  const voiceBtn = document.getElementById("voiceBtn");
  const indicator = document.getElementById("recordingIndicator");
  
  // Update UI - remove pressed state and animations
  voiceBtn.classList.remove("btn-danger", "btn-recording", "recording-pulse");
  voiceBtn.classList.add("btn-secondary");
  voiceBtn.innerHTML = "üé§ –£–¥–µ—Ä–∂–∏–≤–∞–π—Ç–µ –¥–ª—è –∑–∞–ø–∏—Å–∏";
  indicator.style.display = "none";
  
  if (recognition) {
    recognition.stop();
    recognition = null;
  }
}


// ------------------------------
// 5. –û—Å–Ω–æ–≤–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞
// ------------------------------
async function processText() {
  const mode = document.getElementById("mode").value;
  const input = document.getElementById("inputText").value.trim();
  const resultBox = document.getElementById("result");
  const loader = document.getElementById("loader");

  if (!input && mode !== "voice") {
    resultBox.innerText = "–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç.";
    return;
  }

  resultBox.innerText = "";
  loader.style.display = "block";

  try {
    if (mode === "fix") {
      resultBox.innerText = "–ò—Å–ø—Ä–∞–≤–ª—è–µ–º —Ç–µ–∫—Å—Ç...";
      const fixed = await fixHebrew(input);
      resultBox.innerText = fixed;
    }

    if (mode === "translate") {
      resultBox.innerText = "–ü–µ—Ä–µ–≤–æ–¥–∏–º —Ç–µ–∫—Å—Ç...";
      const translated = await translateRuHe(input);
      resultBox.innerText = translated;
    }

    if (mode === "voice") {
      resultBox.innerText = "–°–Ω–∞—á–∞–ª–∞ –Ω–∞–∂–º–∏—Ç–µ \"–ì–æ–ª–æ—Å\", –∑–∞—Ç–µ–º \"–û—Ç–ø—Ä–∞–≤–∏—Ç—å\"";
    }

  } catch (e) {
    console.error("Processing error:", e);
    resultBox.innerText = `–û—à–∏–±–∫–∞: ${e.message}`;
  }

  loader.style.display = "none";
}


// ------------------------------
// 6. –ö–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–µ –∏ –æ—á–∏—Å—Ç–∫–∞
// ------------------------------
function copyResult() {
  const text = document.getElementById("result").innerText;
  navigator.clipboard.writeText(text);
  const alertBox = document.getElementById("copyAlert");
  alertBox.style.display = "block";
  setTimeout(() => alertBox.style.display = "none", 2000);
}

function clearInput() {
  document.getElementById("inputText").value = "";
  document.getElementById("result").innerText = "";
}
</script>

</body>
</html>
