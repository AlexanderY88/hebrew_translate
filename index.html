<!DOCTYPE html>
<html lang="he">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>–ü–æ–º–æ—â–Ω–∏–∫: –†—É—Å—Å–∫–∏–π ‚Üí –ò–≤—Ä–∏—Ç / –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ</title>

<!-- Bootstrap -->
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">

<style>
body {
  padding: 25px;
  background: #f8f9fa;
}
textarea {
  resize: vertical;
  min-height: 150px;
  font-size: 18px;
}
#result {
  white-space: pre-wrap;
  min-height: 150px;
  font-size: 18px;
  background: white;
}
.card {
  border-radius: 12px;
  box-shadow: 0 4px 10px rgba(0,0,0,0.08);
}
button {
  font-size: 18px !important;
}
#copyAlert {
  display: none;
}
.spinner {
  display: none;
}
#recordingIndicator {
  display: none;
}
.btn-recording {
  transform: scale(0.98);
  box-shadow: inset 0 3px 5px rgba(0,0,0,0.3) !important;
}
.recording-pulse {
  animation: recordingPulse 1.5s ease-in-out infinite;
}
@keyframes recordingPulse {
  0%, 100% {
    opacity: 1;
    transform: scale(1);
  }
  50% {
    opacity: 0.7;
    transform: scale(1.05);
  }
}
.recording-dot {
  display: inline-block;
  animation: recordingDot 1s linear infinite;
}
@keyframes recordingDot {
  0%, 20% { opacity: 1; }
  50% { opacity: 0.3; }
  80%, 100% { opacity: 1; }
}

/* Mobile responsiveness - much larger elements and text */
@media (max-width: 800px) {
  body {
    padding: 15px;
    font-size: 16px !important;
  }
  
  .card {
    padding: 20px !important;
  }
  
  h2 {
    font-size: 20px !important;
    margin-bottom: 15px !important;
    font-weight: bold !important;
  }
  
  .form-label {
    font-size: 18px !important;
    font-weight: bold !important;
    margin-bottom: 8px !important;
  }
  
  .form-select {
    font-size: 16px !important;
    padding: 10px !important;
    min-height: 44px !important;
    border-width: 2px !important;
  }
  
  textarea {
    font-size: 20px !important;
    min-height: 60px !important;
    max-height: 300px !important;
    padding: 15px !important;
    line-height: 1.4 !important;
    border-width: 2px !important;
    resize: none !important;
    overflow-y: auto !important;
  }
  
  #result {
    font-size: 20px !important;
    min-height: 60px !important;
    max-height: 300px !important;
    padding: 15px !important;
    line-height: 1.4 !important;
    border-width: 2px !important;
    overflow-y: auto !important;
    resize: none !important;
  }
  
  button {
    font-size: 14px !important;
    padding: 8px 8px !important;
    min-height: 36px !important;
    border-width: 2px !important;
    font-weight: 600 !important;
    line-height: 1.1 !important;
  }
  
  .btn-sm {
    font-size: 12px !important;
    padding: 6px 12px !important;
    min-height: 30px !important;
  }
  
  .gap-2 {
    gap: 0.5rem !important;
  }
  
  .mb-3 {
    margin-bottom: 1.25rem !important;
  }
  
  .alert {
    font-size: 16px !important;
    padding: 12px !important;
  }
  
  .spinner-border {
    width: 2.5rem !important;
    height: 2.5rem !important;
    border-width: 0.25em !important;
  }
  
  /* Voice recording indicator */
  #recordingIndicator .alert {
    font-size: 18px !important;
    padding: 15px !important;
    font-weight: bold !important;
  }
  
  /* Copy alert */
  #copyAlert {
    font-size: 16px !important;
    margin-top: 12px !important;
    font-weight: bold !important;
  }
  
  /* Button layout - 2 buttons per row */
  .d-flex.gap-2 {
    flex-direction: row !important;
    flex-wrap: wrap !important;
  }
  
  .d-flex.gap-2 button {
    width: calc(50% - 0.25rem) !important;
    flex: 0 0 calc(50% - 0.25rem) !important;
    margin-bottom: 0.5rem !important;
  }
}

/* Dynamic text direction classes */
.rtl-text {
  direction: rtl !important;
  text-align: right !important;
}

.ltr-text {
  direction: ltr !important;
  text-align: left !important;
}
</style>
</head>
<body>

<div class="container">

  <div class="card p-4 mb-4">
    <h2 class="mb-3 text-center">–ü–æ–º–æ—â–Ω–∏–∫: –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∏ –ø–µ—Ä–µ–≤–æ–¥</h2>

    <!-- –†–ï–ñ–ò–ú -->
    <div class="mb-3">
      <label class="form-label fw-bold">–†–µ–∂–∏–º:</label>
      <select id="mode" class="form-select">
        <option value="fix">–ò—Å–ø—Ä–∞–≤–∏—Ç—å —Ç–µ–∫—Å—Ç –Ω–∞ –∏–≤—Ä–∏—Ç–µ</option>
        <option value="translate">–†—É—Å—Å–∫–∏–π ‚Üí –ò–≤—Ä–∏—Ç</option>
        <option value="voice">–ì–æ–ª–æ—Å ‚Üí –ò–≤—Ä–∏—Ç</option>
      </select>
    </div>

    <!-- –í–´–ë–û–† –Ø–ó–´–ö–ê –î–õ–Ø –ì–û–õ–û–°–ê -->
    <div class="mb-3">
      <label class="form-label fw-bold">–Ø–∑—ã–∫ –≥–æ–ª–æ—Å–æ–≤–æ–≥–æ –≤–≤–æ–¥–∞:</label>
      <select id="voiceLang" class="form-select">
        <option value="auto">–ê–≤—Ç–æ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ</option>
        <option value="ru-RU">–†—É—Å—Å–∫–∏–π</option>
        <option value="he-IL">–ò–≤—Ä–∏—Ç</option>
      </select>
    </div>

    <!-- –¢–ï–ö–°–¢–û–í–´–ô –í–í–û–î -->
    <div class="mb-3">
      <textarea id="inputText" class="form-control" placeholder="–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç..." 
                oninput="autoResizeTextarea(this); detectAndSetDirection(this)" 
                onpaste="setTimeout(() => { autoResizeTextarea(this); detectAndSetDirection(this); }, 0)"></textarea>
    </div>

    <!-- –ö–ù–û–ü–ö–ò -->
    <div class="d-flex gap-2 mb-3">
      <button class="btn btn-primary flex-fill" onclick="processText()">–û—Ç–ø—Ä–∞–≤–∏—Ç—å</button>
      <button class="btn btn-secondary flex-fill" id="voiceBtn" 
              onmousedown="startVoiceRecording()" 
              onmouseup="stopVoiceRecording()" 
              onmouseleave="stopVoiceRecording()"
              ontouchstart="startVoiceRecording()" 
              ontouchend="stopVoiceRecording()">üé§ –£–¥–µ—Ä–∂–∏–≤–∞–π—Ç–µ –¥–ª—è –∑–∞–ø–∏—Å–∏</button>
      <button class="btn btn-outline-success" onclick="copyInput()">üìã –ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å –≤–≤–æ–¥</button>
      <button class="btn btn-outline-success" onclick="sendInputToWhatsApp()">üì± WhatsApp –≤–≤–æ–¥</button>
      <button class="btn btn-outline-danger" onclick="clearInput()">üóëÔ∏è –û—á–∏—Å—Ç–∏—Ç—å</button>
    </div>

    <!-- –°–ü–ò–ù–ù–ï–† -->
    <div class="text-center spinner" id="loader">
      <div class="spinner-border text-primary" role="status"></div>
      <p>–û–±—Ä–∞–±–æ—Ç–∫–∞...</p>
    </div>

    <!-- –ò–ù–î–ò–ö–ê–¢–û–† –ó–ê–ü–ò–°–ò -->
    <div class="text-center" id="recordingIndicator">
      <div class="alert alert-danger d-inline-block recording-pulse" role="alert">
        <span class="recording-dot">üî¥</span> <strong>–ó–ê–ü–ò–°–¨...</strong> –û—Ç–ø—É—Å—Ç–∏—Ç–µ –∫–Ω–æ–ø–∫—É –¥–ª—è –æ—Å—Ç–∞–Ω–æ–≤–∫–∏
        <div class="spinner-border spinner-border-sm text-danger ms-2" role="status" aria-label="Recording">
          <span class="visually-hidden">Recording...</span>
        </div>
      </div>
    </div>

    <!-- –†–ï–ó–£–õ–¨–¢–ê–¢ -->
    <h4 class="mt-3">–†–µ–∑—É–ª—å—Ç–∞—Ç:</h4>
    <div id="result" class="form-control mb-3"></div>

    <!-- –ö–û–ü–ò–†–û–í–ê–ù–ò–ï –ò –û–¢–ü–†–ê–í–ö–ê -->
    <div class="d-flex gap-2 mb-2">
      <button class="btn btn-success flex-fill" onclick="copyResult()">–°–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å</button>
      <button class="btn btn-success flex-fill" onclick="sendToWhatsApp()">üì± WhatsApp</button>
    </div>
    <div id="copyAlert" class="text-success mt-2 fw-bold">‚úî –°–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–æ!</div>

  </div>

</div>


<!-- JS -->
<script>
// ------------------------------
// 1. Hebrew text correction with multiple approaches
// ------------------------------
// Hebrew correction function with chunk processing for long texts
async function fixHebrew(text) {
  console.log("Starting Hebrew text correction with Google APIs:", text);
  
  // For very long texts (over 1000 characters), process in chunks
  if (text.length > 1000) {
    console.log("Text is long, processing in chunks...");
    return await processHebrewInChunks(text);
  }
  
  // Method 1: Try local corrections first for better performance
  console.log("Trying local Hebrew corrections first...");
  const localCorrected = enhancedHebrewFixes(text);
  if (localCorrected !== text) {
    console.log("Local corrections applied successfully");
    return localCorrected;
  }
  
  // Method 2: Google Translate unofficial API (works without API key)
  try {
    console.log("Trying Google Translate spell check approach...");
    const response = await fetch(`https://translate.googleapis.com/translate_a/single?client=gtx&sl=he&tl=he&dt=t&q=${encodeURIComponent(text)}`, {
      method: "GET",
      headers: {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
      }
    });
    
    if (response.ok) {
      const data = await response.json();
      console.log("Google Translate response:", data);
      
      if (data && data[0] && data[0][0] && data[0][0][0] !== text) {
        const corrected = data[0][0][0];
        return corrected;
      }
    }
  } catch (err) {
    console.log("Google Translate API failed:", err);
  }
  
  // Method 3: Alternative Google endpoint (dict-chrome-ex)
  try {
    console.log("Trying Google dictionary API...");
    const response = await fetch(`https://clients5.google.com/translate_a/t?client=dict-chrome-ex&sl=he&tl=he&q=${encodeURIComponent(text)}`, {
      method: "GET"
    });
    
    if (response.ok) {
      const data = await response.json();
      console.log("Google dictionary response:", data);
      
      if (data && data[0] && data[0] !== text) {
        return data[0];
      }
    }
  } catch (err) {
    console.log("Google dictionary API failed:", err);
  }
  
  // Fallback: Return original text with local improvements
  console.log("All API methods failed, returning text with local corrections");
  return localCorrected;
}

// Process long Hebrew texts in smaller chunks
async function processHebrewInChunks(text) {
  console.log("Processing long Hebrew text in chunks...");
  
  // Split text into sentences or logical chunks
  const sentences = text.match(/[^\.!?]+[\.!?]+/g) || [text];
  const processedSentences = [];
  
  for (let i = 0; i < sentences.length; i++) {
    const sentence = sentences[i].trim();
    if (!sentence) continue;
    
    console.log(`Processing sentence ${i + 1}/${sentences.length}:`, sentence.substring(0, 50) + "...");
    
    // Apply local corrections to each sentence
    const corrected = enhancedHebrewFixes(sentence);
    processedSentences.push(corrected);
    
    // Small delay to avoid rate limiting
    if (i < sentences.length - 1) {
      await new Promise(resolve => setTimeout(resolve, 100));
    }
  }
  
  const result = processedSentences.join(' ');
  console.log("Chunk processing completed");
  return result;
}








// Enhanced Hebrew fixes - comprehensive spelling and grammar correction
function enhancedHebrewFixes(text) {
  let corrected = text;
  console.log("Applying enhanced Hebrew corrections to:", text);
  
  // Comprehensive Hebrew corrections - real spelling mistakes
  const hebrewFixes = [
    // Your example text corrections
    ['◊î◊í◊ô◊ô◊î ◊©◊†◊õ◊™◊ë◊î', '◊î◊í◊ô◊ô◊î ◊©◊†◊õ◊™◊ë◊™'], // ◊î◊í◊ô◊ô◊î ◊©◊†◊õ◊™◊ë◊î ‚Üí ◊î◊í◊ô◊ô◊î ◊©◊†◊õ◊™◊ë◊™ (pronunciation that is written)
    ['◊†◊ê◊ô◊ë◊ô', '◊†◊ê◊ô◊ë◊ô'],             // Already correct but check spelling
    ['◊ë◊ê◊ï◊™◊ï ◊ñ◊û◊ü', '◊ë◊ê◊ï◊™◊ï ◊ñ◊û◊ü'],      // Already correct
    ['◊û◊™◊ß◊ü ◊ê◊ï◊™◊ô', '◊û◊™◊ß◊ü ◊ê◊ï◊™◊ô'],     // Already correct
    
    // Common spelling errors
    ['◊©◊í◊ô◊ï◊™', '◊©◊í◊ô◊ê◊ï◊™'],           // ◊©◊í◊ô◊ï◊™ ‚Üí ◊©◊í◊ô◊ê◊ï◊™ (errors)
    ['◊ò◊¢◊ï◊™', '◊ò◊¢◊ï◊™'],              // Already correct  
    ['◊ò◊¢◊ô◊ï◊™', '◊ò◊¢◊ï◊ô◊ï◊™'],           // ◊ò◊¢◊ô◊ï◊™ ‚Üí ◊ò◊¢◊ï◊ô◊ï◊™ (mistakes)
    ['◊©◊í◊ô◊¢◊ï◊™', '◊©◊í◊ô◊ê◊ï◊™'],          // ◊©◊í◊ô◊¢◊ï◊™ ‚Üí ◊©◊í◊ô◊ê◊ï◊™ (errors)
    ['◊©◊í◊ô◊¢◊î', '◊©◊í◊ô◊ê◊î'],            // ◊©◊í◊ô◊¢◊î ‚Üí ◊©◊í◊ô◊ê◊î (error)
    
    // Grammar - preposition corrections
    ['◊ê◊ù ◊©◊í◊ô◊ê◊ï◊™', '◊¢◊ù ◊©◊í◊ô◊ê◊ï◊™'],    // ◊ê◊ù ‚Üí ◊¢◊ù (with errors)
    ['◊ê◊ù ◊î◊®◊ë◊î', '◊¢◊ù ◊î◊®◊ë◊î'],        // ◊ê◊ù ‚Üí ◊¢◊ù (with many)
    ['◊ê◊ù ◊ë◊¢◊ô◊ï◊™', '◊¢◊ù ◊ë◊¢◊ô◊ï◊™'],      // ◊ê◊ù ‚Üí ◊¢◊ù (with problems)
    ['◊ê◊ù ◊õ◊ú', '◊¢◊ù ◊õ◊ú'],            // ◊ê◊ù ‚Üí ◊¢◊ù (with all)
    
    // Verb conjugation mistakes
    ['◊õ◊ï◊™◊ë', '◊õ◊ï◊™◊ë'],              // Already correct (writes)
    ['◊î◊ï◊ú◊õ', '◊î◊ï◊ú◊ö'],             // ◊î◊ï◊ú◊õ ‚Üí ◊î◊ï◊ú◊ö (goes)
    ['◊ë◊ê', '◊ë◊ê'],                 // Already correct (comes)
    ['◊®◊ï◊¶', '◊®◊ï◊¶◊î'],              // ◊®◊ï◊¶ ‚Üí ◊®◊ï◊¶◊î (wants)
    ['◊ô◊õ◊ï◊ú', '◊ô◊õ◊ï◊ú'],             // Already correct (can)
    ['◊¶◊®◊ô◊õ', '◊¶◊®◊ô◊ö'],             // ◊¶◊®◊ô◊õ ‚Üí ◊¶◊®◊ô◊ö (needs)
    ['◊ê◊ï◊î◊ë', '◊ê◊ï◊î◊ë'],             // Already correct (loves)
    
    // Common word mistakes
    ['◊î◊®◊ë◊ê', '◊î◊®◊ë◊î'],             // ◊î◊®◊ë◊ê ‚Üí ◊î◊®◊ë◊î (many/much)
    ['◊û◊™◊ï◊ó', '◊û◊™◊ï◊ö'],             // ◊û◊™◊ï◊ó ‚Üí ◊û◊™◊ï◊ö (from within)
    ['◊ë◊™◊ï◊ó', '◊ë◊™◊ï◊ö'],             // ◊ë◊™◊ï◊ó ‚Üí ◊ë◊™◊ï◊ö (inside)
    ['◊¢◊ú◊ô◊ï', '◊¢◊ú◊ô◊ï'],             // Already correct (on him)
    ['◊¢◊ú◊ô◊î', '◊¢◊ú◊ô◊î'],             // Already correct (on her)
    
    // Time and place expressions
    ['◊ë◊ê◊ï◊™◊ï ◊ñ◊û◊ü', '◊ë◊ê◊ï◊™◊ï ◊ñ◊û◊ü'],      // Already correct (at the same time)
    ['◊ë◊ñ◊û◊ü', '◊ë◊ñ◊û◊ü'],              // Already correct (in time)
    ['◊ú◊§◊¢◊û◊ô◊ù', '◊ú◊§◊¢◊û◊ô◊ù'],         // Already correct (sometimes)
    ['◊™◊û◊ô◊ì', '◊™◊û◊ô◊ì'],             // Already correct (always)
    ['◊ê◊£ ◊§◊¢◊ù', '◊ê◊£ ◊§◊¢◊ù'],          // Already correct (never)
    
    // Adjectives - common mistakes
    ['◊†◊ê◊ô◊ë◊ô', '◊†◊ê◊ô◊ë◊ô'],           // Already correct (naive)
    ['◊ó◊õ◊ù', '◊ó◊õ◊ù'],               // Already correct (smart)
    ['◊ò◊ï◊ë', '◊ò◊ï◊ë'],               // Already correct (good)
    ['◊®◊¢', '◊®◊¢'],                 // Already correct (bad)
    ['◊ô◊§◊î', '◊ô◊§◊î'],               // Already correct (beautiful)
    ['◊í◊ì◊ï◊ú', '◊í◊ì◊ï◊ú'],             // Already correct (big)
    ['◊ß◊ò◊ü', '◊ß◊ò◊ü'],               // Already correct (small)
    
    // Numbers (common mistakes)
    ['◊ê◊ó◊ì', '◊ê◊ó◊ì'],               // Already correct (one)
    ['◊©◊™◊ô◊ù', '◊©◊™◊ô◊ô◊ù'],           // ◊©◊™◊ô◊ù ‚Üí ◊©◊™◊ô◊ô◊ù (two - feminine)
    ['◊©◊ú◊ï◊©◊î', '◊©◊ú◊ï◊©◊î'],          // Already correct (three - masculine)
    ['◊ê◊®◊ë◊¢◊î', '◊ê◊®◊ë◊¢◊î'],          // Already correct (four - masculine)
    
    // Final letters (sofit) corrections at word boundaries
    ['◊û ', '◊ù '],                 // ◊û ‚Üí ◊ù at word end
    ['◊† ', '◊ü '],                 // ◊† ‚Üí ◊ü at word end
    ['◊õ ', '◊ö '],                 // ◊õ ‚Üí ◊ö at word end
    ['◊§ ', '◊£ '],                 // ◊§ ‚Üí ◊£ at word end
    ['◊¶ ', '◊• ']                  // ◊¶ ‚Üí ◊• at word end
  ];
  
  let changesMade = false;
  
  // Apply word-level corrections
  for (const [wrong, right] of hebrewFixes) {
    if (wrong !== right && corrected.includes(wrong)) {
      console.log(`Applying Hebrew correction: "${wrong}" ‚Üí "${right}"`);
      corrected = corrected.replace(new RegExp(wrong.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g'), right);
      changesMade = true;
    }
  }
  
  // Fix final letters at word boundaries with regex (most important Hebrew rule)
  const finalLetterPatterns = [
    [/◊û(?=\s|$|[.!?,:;])/g, '◊ù'], // ◊û ‚Üí ◊ù at word end
    [/◊†(?=\s|$|[.!?,:;])/g, '◊ü'], // ◊† ‚Üí ◊ü at word end  
    [/◊õ(?=\s|$|[.!?,:;])/g, '◊ö'], // ◊õ ‚Üí ◊ö at word end
    [/◊§(?=\s|$|[.!?,:;])/g, '◊£'], // ◊§ ‚Üí ◊£ at word end
    [/◊¶(?=\s|$|[.!?,:;])/g, '◊•']  // ◊¶ ‚Üí ◊• at word end
  ];
  
  for (const [pattern, replacement] of finalLetterPatterns) {
    const before = corrected;
    corrected = corrected.replace(pattern, replacement);
    if (before !== corrected) {
      console.log(`Applied final letter correction: ${pattern.source} ‚Üí ${replacement}`);
      changesMade = true;
    }
  }
  
  // Clean up spacing and punctuation
  corrected = corrected
    .replace(/\s+/g, ' ')        // Multiple spaces to single space
    .replace(/\s+([.!?,:;])/g, '$1') // Remove space before punctuation
    .trim();
  
  // Add period if substantial text lacks ending punctuation
  if (corrected && corrected.length > 15 && !/[.!?]$/.test(corrected)) {
    corrected += '.';
    changesMade = true;
  }
  
  console.log(`Hebrew correction result: "${corrected}"`);
  console.log(`Changes made: ${changesMade}`);
  
  return corrected;
}



// Advanced Hebrew text correction function
function advancedHebrewCorrection(text) {
  let corrected = text;
  
  // Common Hebrew spelling mistakes and corrections
  const commonMistakes = {
    // Your specific example errors
    '◊©◊í◊ô◊ï◊™': '◊©◊í◊ô◊ê◊ï◊™',  // ◊©◊í◊ô◊ï◊™ ‚Üí ◊©◊í◊ô◊ê◊ï◊™ (errors)
    '◊î◊©◊í◊ô◊ê◊ï◊™': '◊î◊©◊í◊ô◊ê◊ï◊™', // This is actually correct
    
    // Common spelling errors
    '◊ê◊ù': '◊¢◊ù',      // ◊ê◊ù ‚Üí ◊¢◊ù (with) when used as preposition
    '◊ë◊ß◊ô◊™': '◊ë◊ß◊ô◊•',   // ◊ë◊ß◊ô◊™ ‚Üí ◊ë◊ß◊ô◊• (in summer)
    '◊î◊ú◊õ': '◊î◊ú◊ö',     // ◊î◊ú◊õ ‚Üí ◊î◊ú◊ö (went)
    '◊û◊ô◊ì': '◊û◊ô◊ì',     // Already correct
    '◊ú◊ô◊ì◊î': '◊ú◊ô◊ì◊î',   // Already correct
    '◊©◊ú◊ï◊©': '◊©◊ú◊ï◊©',   // Already correct
    '◊ê◊®◊ë◊¢': '◊ê◊®◊ë◊¢',   // Already correct
    
    // Common word confusions
    '◊©◊ú◊ê': '◊©◊ú◊ê',     // Already correct
    '◊ë◊ú': '◊ë◊ú◊ô',      // ◊ë◊ú ‚Üí ◊ë◊ú◊ô (without)
    '◊ß◊®◊î': '◊ß◊®◊ê',     // ◊ß◊®◊î ‚Üí ◊ß◊®◊ê (called/read) context dependent
    '◊©◊û◊¢': '◊©◊û◊¢',     // Already correct
    '◊®◊ê◊î': '◊®◊ê◊î',     // Already correct
    
    // Prefix errors
    '◊ë÷æ': '◊ë',
    '◊ú÷æ': '◊ú', 
    '◊û÷æ': '◊û',
    '◊©÷æ': '◊©',
    '◊î÷æ': '◊î',
    '◊õ÷æ': '◊õ',
    
    // Final letter corrections (sofit)
    '◊û ': '◊ù ',
    '◊† ': '◊ü ',
    '◊¶ ': '◊• ',
    '◊§ ': '◊£ ',
    '◊õ ': '◊ö ',
    
    // Common typos and mistakes
    '◊¢◊ú◊ô◊ï': '◊¢◊ú◊ô◊ï',   // Already correct
    '◊¢◊ú◊ô◊î': '◊¢◊ú◊ô◊î',   // Already correct
    '◊ë◊©◊ë◊ô◊ú': '◊ë◊©◊ë◊ô◊ú', // Already correct
    '◊ë◊ê◊û◊™': '◊ë◊ê◊û◊™',   // Already correct
    '◊ú◊§◊¢◊û◊ô◊ù': '◊ú◊§◊¢◊û◊ô◊ù', // Already correct
    '◊î◊û◊ï◊ü': '◊î◊û◊ï◊ü',   // Already correct
    '◊î◊®◊ë◊î': '◊î◊®◊ë◊î',   // Already correct
    
    // Letter confusions (common typing errors)
    // '◊õ◊™◊ô◊ë': '◊õ◊™◊ë',    // Removed - context dependent
    '◊í◊ì◊ï◊ú◊î': '◊í◊ì◊ï◊ú◊î', // Already correct
    '◊ß◊ò◊†◊î': '◊ß◊ò◊†◊î',   // Already correct
    '◊ô◊§◊î': '◊ô◊§◊î',     // Already correct
    '◊®◊¢': '◊®◊¢',       // Already correct
    
    // Numbers and common words
    '◊ê◊ó◊ì': '◊ê◊ó◊ì',     // Already correct
    '◊©◊™◊ô◊ù': '◊©◊™◊ô◊ô◊ù',  // ◊©◊™◊ô◊ù ‚Üí ◊©◊™◊ô◊ô◊ù (two - feminine)
    '◊©◊ú◊ï◊©◊î': '◊©◊ú◊ï◊©◊î', // Already correct
    '◊ê◊®◊ë◊¢◊î': '◊ê◊®◊ë◊¢◊î', // Already correct
    '◊ó◊û◊ô◊©◊î': '◊ó◊û◊ô◊©◊î', // Already correct
    
    // Demonstratives and pronouns
    '◊î◊ñ◊î': '◊î◊ñ◊î',     // Already correct
    '◊î◊ñ◊ê◊™': '◊î◊ñ◊ê◊™',   // Already correct
    '◊î◊ê◊ú◊î': '◊î◊ê◊ú◊î',   // Already correct
    '◊©◊ú◊ô': '◊©◊ú◊ô',     // Already correct
    '◊©◊ú◊ö': '◊©◊ú◊ö',     // Already correct
    '◊©◊ú◊ï': '◊©◊ú◊ï',     // Already correct
    '◊©◊ú◊î': '◊©◊ú◊î'      // Already correct
  };
  
  console.log("Starting Hebrew correction for text:", corrected);
  let hasChanges = false;
  
  // Comprehensive Hebrew spelling and grammar corrections
  const hebrewCorrections = [
    // Most common spelling mistakes
    ['◊©◊í◊ô◊ï◊™', '◊©◊í◊ô◊ê◊ï◊™'],        // ◊©◊í◊ô◊ï◊™ ‚Üí ◊©◊í◊ô◊ê◊ï◊™ (errors)
    ['◊©◊í◊ô◊¢◊ï◊™', '◊©◊í◊ô◊ê◊ï◊™'],       // ◊©◊í◊ô◊¢◊ï◊™ ‚Üí ◊©◊í◊ô◊ê◊ï◊™ (errors)
    ['◊©◊í◊ô◊¢◊™', '◊©◊í◊ô◊ê◊™'],         // ◊©◊í◊ô◊¢◊™ ‚Üí ◊©◊í◊ô◊ê◊™ (error of)
    ['◊ò◊¢◊ï◊™', '◊ò◊¢◊ï◊™'],           // Already correct but included for completeness
    ['◊ò◊¢◊ï◊ô◊ï◊™', '◊ò◊¢◊ï◊ô◊ï◊™'],       // Already correct
    
    // Preposition corrections (very common mistakes)
    ['◊ê◊ù ◊©◊í◊ô◊ê◊ï◊™', '◊¢◊ù ◊©◊í◊ô◊ê◊ï◊™'], // ◊ê◊ù ‚Üí ◊¢◊ù (with errors)
    ['◊ê◊ù ◊ë◊¢◊ô◊ï◊™', '◊¢◊ù ◊ë◊¢◊ô◊ï◊™'],   // ◊ê◊ù ‚Üí ◊¢◊ù (with problems)  
    ['◊ê◊ù ◊ò◊¢◊ï◊ô◊ï◊™', '◊¢◊ù ◊ò◊¢◊ï◊ô◊ï◊™'], // ◊ê◊ù ‚Üí ◊¢◊ù (with mistakes)
    ['◊ê◊ù ◊î◊®◊ë◊î', '◊¢◊ù ◊î◊®◊ë◊î'],     // ◊ê◊ù ‚Üí ◊¢◊ù (with many)
    ['◊ê◊ù ◊õ◊ú', '◊¢◊ù ◊õ◊ú'],         // ◊ê◊ù ‚Üí ◊¢◊ù (with all)
    
    // Writing/script/text corrections
    ['◊õ◊™◊ë ◊í◊ì◊ï◊ú', '◊õ◊™◊ô◊ë ◊í◊ì◊ï◊ú'],  // ◊õ◊™◊ë ‚Üí ◊õ◊™◊ô◊ë (large script)
    ['◊õ◊™◊ë ◊ß◊ò◊ü', '◊õ◊™◊ô◊ë ◊ß◊ò◊ü'],    // ◊õ◊™◊ë ‚Üí ◊õ◊™◊ô◊ë (small script)
    ['◊õ◊™◊ë ◊ô◊ì', '◊õ◊™◊ë ◊ô◊ì'],       // Already correct (handwriting)
    
    // Common Hebrew word mistakes
    ['◊î◊®◊ë◊ê', '◊î◊®◊ë◊î'],          // ◊î◊®◊ë◊ê ‚Üí ◊î◊®◊ë◊î (many/much)
    ['◊ê◊ó◊®◊ô', '◊ê◊ó◊®◊ô'],          // Already correct
    ['◊ú◊§◊†◊ô', '◊ú◊§◊†◊ô'],          // Already correct
    ['◊ë◊ñ◊û◊ü', '◊ë◊ñ◊û◊ü'],          // Already correct
    ['◊ë◊û◊ß◊ï◊ù', '◊ë◊û◊ß◊ï◊ù'],        // Already correct
    
    // Verb conjugation mistakes
    ['◊î◊ï◊ú◊õ', '◊î◊ï◊ú◊ö'],          // ◊î◊ï◊ú◊õ ‚Üí ◊î◊ï◊ú◊ö (goes/walking)
    ['◊ë◊ê', '◊ë◊ê'],              // Already correct (comes)
    ['◊®◊ï◊¶◊î', '◊®◊ï◊¶◊î'],          // Already correct (wants)
    ['◊ô◊õ◊ï◊ú', '◊ô◊õ◊ï◊ú'],          // Already correct (can)
    ['◊¶◊®◊ô◊õ', '◊¶◊®◊ô◊ö'],          // ◊¶◊®◊ô◊õ ‚Üí ◊¶◊®◊ô◊ö (needs)
    
    // Articles and demonstratives
    ['◊î◊ñ◊ê', '◊î◊ñ◊î'],            // ◊î◊ñ◊ê ‚Üí ◊î◊ñ◊î (this - masculine)
    ['◊î◊ñ◊ê◊™', '◊î◊ñ◊ê◊™'],          // Already correct (this - feminine)
    ['◊î◊ê◊ú◊î', '◊î◊ê◊ú◊î'],          // Already correct (these)
    
    // Final letter corrections (sofit letters) - most important Hebrew correction
    ['◊û ', '◊ù '],              // ◊û ‚Üí ◊ù at word end
    ['◊† ', '◊ü '],              // ◊† ‚Üí ◊ü at word end
    ['◊õ ', '◊ö '],              // ◊õ ‚Üí ◊ö at word end  
    ['◊§ ', '◊£ '],              // ◊§ ‚Üí ◊£ at word end
    ['◊¶ ', '◊• '],              // ◊¶ ‚Üí ◊• at word end
    
    // Numbers (common mistakes)
    ['◊©◊™◊ô◊ô◊ù', '◊©◊™◊ô◊ô◊ù'],        // Already correct (two - feminine)
    ['◊©◊†◊ô◊ô◊ù', '◊©◊†◊ô◊ô◊ù'],        // Already correct (two - masculine)
    ['◊©◊ú◊ï◊©◊î', '◊©◊ú◊ï◊©◊î'],        // Already correct (three - masculine)
    ['◊©◊ú◊ï◊©', '◊©◊ú◊ï◊©'],          // Already correct (three - feminine)
    
    // Time expressions
    ['◊î◊ô◊ï◊ù', '◊î◊ô◊ï◊ù'],          // Already correct (today)
    ['◊ê◊™◊û◊ï◊ú', '◊ê◊™◊û◊ï◊ú'],        // Already correct (yesterday)
    ['◊û◊ó◊®', '◊û◊ó◊®'],            // Already correct (tomorrow)
    
    // Common adverbs
    ['◊û◊ê◊ï◊ì', '◊û◊ê◊ï◊ì'],          // Already correct (very)
    ['◊ß◊¶◊™', '◊ß◊¶◊™'],            // Already correct (a little)
    ['◊î◊®◊ë◊î', '◊î◊®◊ë◊î'],          // Already correct (much/many)
    ['◊õ◊û◊¢◊ò', '◊õ◊û◊¢◊ò'],          // Already correct (almost)
    ['◊ê◊ï◊ú◊ô', '◊ê◊ï◊ú◊ô']           // Already correct (maybe)
  ];
  
  // Apply corrections
  for (const [wrong, right] of hebrewCorrections) {
    if (corrected.includes(wrong)) {
      console.log(`Applying Hebrew correction: "${wrong}" ‚Üí "${right}"`);
      corrected = corrected.replace(new RegExp(wrong.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g'), right);
      hasChanges = true;
    }
  }
  
  console.log("After Hebrew corrections:", corrected, "Changes made:", hasChanges);
  
  // Apply individual word corrections from dictionary (disabled to prevent conflicts)
  // Note: Commenting out dictionary corrections to avoid conflicts with direct corrections
  /*
  for (const [mistake, correction] of Object.entries(commonMistakes)) {
    if (corrected.includes(mistake) && mistake !== correction) {
      console.log(`Dictionary correction: "${mistake}" ‚Üí "${correction}"`);
      // Use word boundaries for Hebrew
      const beforeDict = corrected;
      corrected = corrected.replace(new RegExp(`(^|\\s)${mistake.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}(\\s|$)`, 'g'), `$1${correction}$2`);
      if (beforeDict !== corrected) {
        hasChanges = true;
      }
    }
  }
  */
  
  console.log("Hebrew correction result:", corrected, "Total changes made:", hasChanges);
  
  // Return the original text if no changes were made
  return hasChanges ? corrected : text;
  
  // Fix final letters at end of words
  corrected = corrected
    .replace(/◊û(?=\s|$|[.!?])/g, '◊ù')
    .replace(/◊†(?=\s|$|[.!?])/g, '◊ü')
    .replace(/◊¶(?=\s|$|[.!?])/g, '◊•')
    .replace(/◊§(?=\s|$|[.!?])/g, '◊£')
    .replace(/◊õ(?=\s|$|[.!?])/g, '◊ö');
  
  // Remove extra spaces and fix punctuation
  corrected = corrected
    .replace(/\s+/g, ' ')  // Multiple spaces to single space
    .replace(/^\s+|\s+$/g, '')  // Trim start and end
    .replace(/([\.!?])\s*([◊ê-◊™])/g, '$1 $2')  // Space after punctuation
    .replace(/([◊ê-◊™])\s*([\.!?])/g, '$1$2')  // No space before punctuation
    .replace(/\?\?+/g, '?')  // Multiple question marks
    .replace(/!!+/g, '!')    // Multiple exclamation marks
    .replace(/\.\.+/g, '...')  // Multiple dots to ellipsis
    .replace(/,,+/g, ',');   // Multiple commas
  
  // Fix Hebrew quotation marks
  corrected = corrected
    .replace(/"/g, '"')  // Replace straight quotes
    .replace(/'/g, "'")  // Replace straight apostrophes
    .replace(/◊¥/g, '"')  // Hebrew quote mark
    .replace(/◊≥/g, "'"); // Hebrew apostrophe
    
  // Add proper Hebrew punctuation
  if (corrected.length > 0 && !/[.!?]$/.test(corrected)) {
    // Add period if sentence seems complete
    const words = corrected.split(/\s+/);
    if (words.length >= 2) {
      corrected += '.';
    }
  }
  
  return corrected;
}

// Basic Hebrew text cleanup (kept for compatibility)
function basicHebrewCleanup(text) {
  return advancedHebrewCorrection(text);
}


// ------------------------------
// 2. Translation RU ‚Üí HE using MyMemory API
// ------------------------------
async function translateRuHe(text) {
  try {
    // MyMemory API - free translation service that allows CORS
    const url = `https://api.mymemory.translated.net/get?q=${encodeURIComponent(text)}&langpair=ru|he`;
    
    const response = await fetch(url, {
      method: "GET",
      headers: {
        "Accept": "application/json"
      }
    });

    if (!response.ok) {
      throw new Error(`Translation service returned ${response.status}`);
    }

    const data = await response.json();
    
    if (data && data.responseData && data.responseData.translatedText) {
      return data.responseData.translatedText;
    } else {
      throw new Error("Invalid response format from translation service");
    }
    
  } catch (err) {
    console.error("Translation failed:", err);
    
    // Fallback: Basic transliteration for common Russian-Hebrew words
    const fallbackTranslation = fallbackRuToHe(text);
    if (fallbackTranslation !== text) {
      return fallbackTranslation + " (–±–∞–∑–æ–≤—ã–π –ø–µ—Ä–µ–≤–æ–¥)";
    }
    
    throw new Error("–ü–µ—Ä–µ–≤–æ–¥ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ –∏–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –¥—Ä—É–≥–æ–π —Å–µ—Ä–≤–∏—Å.");
  }
}

// ------------------------------
// 3. Fallback translation for common words
// ------------------------------
function fallbackRuToHe(text) {
  const commonWords = {
    '–ø—Ä–∏–≤–µ—Ç': '◊©◊ú◊ï◊ù',
    '—Å–ø–∞—Å–∏–±–æ': '◊™◊ï◊ì◊î',
    '–ø–æ–∂–∞–ª—É–π—Å—Ç–∞': '◊ë◊ë◊ß◊©◊î',
    '–¥–∞': '◊õ◊ü',
    '–Ω–µ—Ç': '◊ú◊ê',
    '—Ö–æ—Ä–æ—à–æ': '◊ò◊ï◊ë',
    '–ø–ª–æ—Ö–æ': '◊®◊¢',
    '–≤–æ–¥–∞': '◊û◊ô◊ù',
    '–¥–æ–º': '◊ë◊ô◊™',
    '–º–∞–º–∞': '◊ê◊û◊ê',
    '–ø–∞–ø–∞': '◊ê◊ë◊ê',
    '—Å—ã–Ω': '◊ë◊ü',
    '–¥–æ—á—å': '◊ë◊™',
    '–±—Ä–∞—Ç': '◊ê◊ó',
    '—Å–µ—Å—Ç—Ä–∞': '◊ê◊ó◊ï◊™',
    '–¥—Ä—É–≥': '◊ó◊ë◊®',
    '–ø–æ–¥—Ä—É–≥–∞': '◊ó◊ë◊®◊î',
    '—Ä–∞–±–æ—Ç–∞': '◊¢◊ë◊ï◊ì◊î',
    '—à–∫–æ–ª–∞': '◊ë◊ô◊™ ◊°◊§◊®',
    '—É–Ω–∏–≤–µ—Ä—Å–∏—Ç–µ—Ç': '◊ê◊ï◊†◊ô◊ë◊®◊°◊ô◊ò◊î',
    '–≤—Ä–µ–º—è': '◊ñ◊û◊ü',
    '–¥–µ–Ω—å': '◊ô◊ï◊ù',
    '–Ω–æ—á—å': '◊ú◊ô◊ú◊î',
    '—É—Ç—Ä–æ': '◊ë◊ß◊®',
    '–≤–µ—á–µ—Ä': '◊¢◊®◊ë',
    '–∫—Ä–∞—Å–∏–≤—ã–π': '◊ô◊§◊î',
    '–±–æ–ª—å—à–æ–π': '◊í◊ì◊ï◊ú',
    '–º–∞–ª–µ–Ω—å–∫–∏–π': '◊ß◊ò◊ü',
    '–Ω–æ–≤—ã–π': '◊ó◊ì◊©',
    '—Å—Ç–∞—Ä—ã–π': '◊ô◊©◊ü',
    '–∫—Ä–∞—Å–Ω—ã–π': '◊ê◊ì◊ï◊ù',
    '—Å–∏–Ω–∏–π': '◊õ◊ó◊ï◊ú',
    '–∑–µ–ª–µ–Ω—ã–π': '◊ô◊®◊ï◊ß',
    '–∂–µ–ª—Ç—ã–π': '◊¶◊î◊ï◊ë',
    '—á–µ—Ä–Ω—ã–π': '◊©◊ó◊ï◊®',
    '–±–µ–ª—ã–π': '◊ú◊ë◊ü'
  };
  
  let translated = text.toLowerCase();
  
  // Replace whole words only
  for (const [russian, hebrew] of Object.entries(commonWords)) {
    const regex = new RegExp(`\\b${russian}\\b`, 'gi');
    translated = translated.replace(regex, hebrew);
  }
  
  return translated;
}


// ------------------------------
// 4. –ì–æ–ª–æ—Å–æ–≤–æ–π –≤–≤–æ–¥ (RU/HE + –∞–≤—Ç–æ) - Press and Hold
// ------------------------------
let recognition = null;
let isRecording = false;

function detectLanguage(text) {
  // Hebrew character detection
  const hebrew = /[\u0590-\u05FF]/;
  const russianCyrillic = /[\u0400-\u04FF]/;
  
  console.log("Detecting language for text:", text);
  
  if (hebrew.test(text)) {
    console.log("Detected Hebrew text");
    return "he-IL";
  } else if (russianCyrillic.test(text)) {
    console.log("Detected Russian text");
    return "ru-RU";
  } else {
    console.log("No specific language detected, defaulting to Russian");
    return "ru-RU";
  }
}

function detectAndSetDirection(element) {
  const text = element.value || element.innerText || element.textContent || '';
  
  // Hebrew character detection
  const hebrew = /[\u0590-\u05FF]/;
  const hasHebrew = hebrew.test(text);
  
  // Remove existing direction classes
  element.classList.remove('rtl-text', 'ltr-text');
  
  if (hasHebrew) {
    // Hebrew text - use RTL
    element.classList.add('rtl-text');
    console.log('Set RTL direction for Hebrew text');
  } else {
    // Russian/English text - use LTR
    element.classList.add('ltr-text');
    console.log('Set LTR direction for non-Hebrew text');
  }
}

function formatSpeechText(text) {
  // Clean up the speech text and add proper punctuation
  let formatted = text.trim();
  
  // Convert common speech commands to punctuation (Russian)
  const russianCommands = {
    '—Ç–æ—á–∫–∞': '.',
    '–∑–∞–ø—è—Ç–∞—è': ',', 
    '–≤–æ—Å–∫–ª–∏—Ü–∞—Ç–µ–ª—å–Ω—ã–π –∑–Ω–∞–∫': '!',
    '–≤–æ–ø—Ä–æ—Å–∏—Ç–µ–ª—å–Ω—ã–π –∑–Ω–∞–∫': '?',
    '–¥–≤–æ–µ—Ç–æ—á–∏–µ': ':',
    '—Ç–æ—á–∫–∞ —Å –∑–∞–ø—è—Ç–æ–π': ';',
    '—Ç–∏—Ä–µ': ' - ',
    '–∫–∞–≤—ã—á–∫–∏': '"',
    '–æ—Ç–∫—Ä—ã—Ç—å –∫–∞–≤—ã—á–∫–∏': '"',
    '–∑–∞–∫—Ä—ã—Ç—å –∫–∞–≤—ã—á–∫–∏': '"',
    '–Ω–æ–≤–∞—è —Å—Ç—Ä–æ–∫–∞': '\n',
    '–∞–±–∑–∞—Ü': '\n\n'
  };
  
  // Convert common speech commands to punctuation (Hebrew)
  const hebrewCommands = {
    '◊†◊ß◊ï◊ì◊î': '.',
    '◊§◊°◊ô◊ß': ',',
    '◊°◊ô◊û◊ü ◊ß◊®◊ô◊ê◊î': '!', 
    '◊°◊ô◊û◊ü ◊©◊ê◊ú◊î': '?',
    '◊†◊ß◊ï◊ì◊ï◊™◊ô◊ô◊ù': ':',
    '◊†◊ß◊ï◊ì◊î ◊ï◊§◊°◊ô◊ß': ';',
    '◊û◊ß◊£': ' - ',
    '◊û◊®◊õ◊ê◊ï◊™': '"',
    '◊©◊ï◊®◊î ◊ó◊ì◊©◊î': '\n'
  };
  
  // Apply Russian commands
  for (const [command, punctuation] of Object.entries(russianCommands)) {
    const regex = new RegExp(`\\b${command}\\b`, 'gi');
    formatted = formatted.replace(regex, punctuation);
  }
  
  // Apply Hebrew commands  
  for (const [command, punctuation] of Object.entries(hebrewCommands)) {
    const regex = new RegExp(`\\b${command}\\b`, 'gi');
    formatted = formatted.replace(regex, punctuation);
  }
  
  // Capitalize first letter of sentences
  formatted = formatted.replace(/(^|[.!?]\s+)([a-z–∞-—è])/g, (match, prefix, letter) => {
    return prefix + letter.toUpperCase();
  });
  
  // Clean up extra spaces
  formatted = formatted.replace(/\s+/g, ' ').trim();
  
  // Auto-add period at the end if missing punctuation
  const endsWithPunctuation = /[.!?„ÄÇÔºÅÔºü]$/.test(formatted);
  if (formatted.length > 0 && !endsWithPunctuation) {
    // Only add period if it looks like a complete sentence (more than 3 words)
    const wordCount = formatted.split(/\s+/).length;
    if (wordCount >= 3) {
      formatted += '.';
    }
  }
  
  return formatted;
}

function startVoiceRecording() {
  if (isRecording) return;
  
  // Check current mode - voice input should work for all modes
  const currentMode = document.getElementById("mode").value;
  console.log("Starting voice recording in mode:", currentMode);
  
  if (!("webkitSpeechRecognition" in window) && !("SpeechRecognition" in window)) {
    alert("–í–∞—à –±—Ä–∞—É–∑–µ—Ä –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –≥–æ–ª–æ—Å–æ–≤–æ–π –≤–≤–æ–¥.");
    return;
  }

  isRecording = true;
  const voiceBtn = document.getElementById("voiceBtn");
  const indicator = document.getElementById("recordingIndicator");
  
  // Update UI with pressed state and animation
  voiceBtn.classList.remove("btn-secondary");
  voiceBtn.classList.add("btn-danger", "btn-recording", "recording-pulse");
  voiceBtn.innerHTML = '<span class="recording-dot">üî¥</span> –ó–∞–ø–∏—Å—å...';
  indicator.style.display = "block";

  // Setup recognition
  recognition = new (window.SpeechRecognition || window.webkitSpeechRecognition)();
  
  const selected = document.getElementById("voiceLang").value;
  console.log("Selected voice language:", selected);
  console.log("Current mode:", currentMode);
  
  // Determine recognition language based on mode and selection
  let recognitionLang = "ru-RU"; // Default
  
  if (currentMode === "translate") {
    // Russian to Hebrew mode - use Russian for voice input
    recognitionLang = "ru-RU";
    console.log("Translation mode: using Russian voice input");
  } else if (currentMode === "fix") {
    // Hebrew correction mode - use Hebrew for voice input
    if (selected === "he-IL") {
      recognitionLang = "he-IL";
      console.log("Hebrew correction mode: using Hebrew voice input");
      
      // Set additional properties for Hebrew recognition
      if (recognition.webkitSpeechRecognition) {
        recognition.webkitGrammar = false; // Disable grammar for better Hebrew support
      }
    } else if (selected === "ru-RU") {
      recognitionLang = "ru-RU";
      console.log("Hebrew correction mode: using Russian voice input");
    } else if (selected === "auto") {
      recognitionLang = "ru-RU";
      console.log("Hebrew correction mode: auto-detection, defaulting to Russian");
    }
  } else if (currentMode === "voice") {
    // Voice mode - use selected language
    if (selected === "he-IL") {
      recognitionLang = "he-IL";
      console.log("Voice mode: using Hebrew");
    } else if (selected === "auto") {
      recognitionLang = "ru-RU";
      console.log("Voice mode: auto-detection, defaulting to Russian");
    } else {
      recognitionLang = selected;
      console.log("Voice mode: using selected language", selected);
    }
  }
  
  recognition.lang = recognitionLang;
  console.log("Final recognition language set to:", recognition.lang);
  
  console.log("Recognition language set to:", recognition.lang);
  recognition.continuous = true;
  recognition.interimResults = true;
  
  // Enable punctuation and formatting
  if (recognition.webkitSpeechRecognition) {
    recognition.webkitGrammar = true;
  }
  
  // Additional settings for better punctuation support
  try {
    recognition.maxAlternatives = 1;
    recognition.serviceURI = recognition.serviceURI || '';
  } catch (e) {
    // Ignore if not supported
  }

  recognition.onresult = event => {
    let finalTranscript = '';
    
    for (let i = event.resultIndex; i < event.results.length; i++) {
      if (event.results[i].isFinal) {
        finalTranscript += event.results[i][0].transcript;
      }
    }
    
    if (finalTranscript) {
      console.log("Speech recognition result:", finalTranscript);
      console.log("Recognition was set to language:", recognition ? recognition.lang : "recognition is null");
      
      // Detect what language was actually recognized
      const detectedLang = detectLanguage(finalTranscript);
      console.log("Detected language in result:", detectedLang);
      
      // Clean and format the transcript before inserting
      let formattedText = formatSpeechText(finalTranscript);
      
      const inputField = document.getElementById("inputText");
      const currentText = inputField.value.trim();
      
      // Smart spacing: add space if there's already text and it doesn't end with punctuation
      let separator = "";
      if (currentText) {
        const lastChar = currentText.slice(-1);
        const punctuation = /[.!?„ÄÇÔºÅÔºü]/;
        separator = punctuation.test(lastChar) ? " " : " ";
      }
      
      inputField.value = currentText + separator + formattedText;
    }
  };

  recognition.onerror = event => {
    console.error("Speech recognition error:", event.error);
    
    // Don't stop recording on certain error types that are recoverable
    if (event.error === 'aborted' || event.error === 'no-speech') {
      console.log("Recoverable error, continuing...");
      return;
    }
    
    // Only stop on serious errors
    if (event.error === 'not-allowed' || event.error === 'service-not-allowed') {
      alert("–ú–∏–∫—Ä–æ—Ñ–æ–Ω –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω. –†–∞–∑—Ä–µ—à–∏—Ç–µ –¥–æ—Å—Ç—É–ø –∫ –º–∏–∫—Ä–æ—Ñ–æ–Ω—É –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö –±—Ä–∞—É–∑–µ—Ä–∞.");
    }
    
    stopVoiceRecording();
  };

  recognition.onend = event => {
    console.log("Speech recognition ended");
    // Only restart if we're still supposed to be recording
    if (isRecording) {
      console.log("Restarting recognition...");
      try {
        recognition.start();
      } catch (e) {
        console.log("Could not restart recognition:", e);
        stopVoiceRecording();
      }
    }
  };

  try {
    recognition.start();
  } catch (e) {
    console.error("Could not start speech recognition:", e);
    stopVoiceRecording();
  }
}

function stopVoiceRecording() {
  if (!isRecording) return;
  
  console.log("Stopping voice recording...");
  isRecording = false;
  const voiceBtn = document.getElementById("voiceBtn");
  const indicator = document.getElementById("recordingIndicator");
  
  // Update UI - remove pressed state and animations
  voiceBtn.classList.remove("btn-danger", "btn-recording", "recording-pulse");
  voiceBtn.classList.add("btn-secondary");
  voiceBtn.innerHTML = "üé§ –£–¥–µ—Ä–∂–∏–≤–∞–π—Ç–µ –¥–ª—è –∑–∞–ø–∏—Å–∏";
  indicator.style.display = "none";
  
  if (recognition) {
    try {
      recognition.stop();
    } catch (e) {
      console.log("Error stopping recognition:", e);
    }
    recognition = null;
  }
}


// ------------------------------
// 5. –û—Å–Ω–æ–≤–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞
// ------------------------------
async function processText() {
  const mode = document.getElementById("mode").value;
  const input = document.getElementById("inputText").value.trim();
  const resultBox = document.getElementById("result");
  const loader = document.getElementById("loader");

  if (!input && mode !== "voice") {
    resultBox.innerText = "–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç.";
    autoResizeResultField(resultBox);
    return;
  }

  resultBox.innerText = "";
  loader.style.display = "block";

  try {
    if (mode === "fix") {
      resultBox.innerText = "–ò—Å–ø—Ä–∞–≤–ª—è–µ–º —Ç–µ–∫—Å—Ç...";
      autoResizeResultField(resultBox);
      const fixed = await fixHebrew(input);
      resultBox.innerText = fixed;
      detectAndSetDirection(resultBox);
      autoResizeResultField(resultBox);
    }

    if (mode === "translate") {
      resultBox.innerText = "–ü–µ—Ä–µ–≤–æ–¥–∏–º —Ç–µ–∫—Å—Ç...";
      autoResizeResultField(resultBox);
      const translated = await translateRuHe(input);
      resultBox.innerText = translated;
      detectAndSetDirection(resultBox);
      autoResizeResultField(resultBox);
    }

    if (mode === "voice") {
      resultBox.innerText = "–°–Ω–∞—á–∞–ª–∞ –Ω–∞–∂–º–∏—Ç–µ \"–ì–æ–ª–æ—Å\", –∑–∞—Ç–µ–º \"–û—Ç–ø—Ä–∞–≤–∏—Ç—å\"";
      autoResizeResultField(resultBox);
    }

  } catch (e) {
    console.error("Processing error:", e);
    resultBox.innerText = `–û—à–∏–±–∫–∞: ${e.message}`;
    autoResizeResultField(resultBox);
  }

  loader.style.display = "none";
}


// ------------------------------
// 6. –ö–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–µ –∏ –æ—á–∏—Å—Ç–∫–∞
// ------------------------------
function copyResult() {
  const text = document.getElementById("result").innerText;
  navigator.clipboard.writeText(text);
  const alertBox = document.getElementById("copyAlert");
  alertBox.style.display = "block";
  setTimeout(() => alertBox.style.display = "none", 2000);
}

function copyInput() {
  const text = document.getElementById("inputText").value;
  if (!text.trim()) {
    alert("–ù–µ—Ç —Ç–µ–∫—Å—Ç–∞ –¥–ª—è –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è");
    return;
  }
  navigator.clipboard.writeText(text);
  const alertBox = document.getElementById("copyAlert");
  alertBox.innerText = "‚úî –í–≤–æ–¥ —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω!";
  alertBox.style.display = "block";
  setTimeout(() => alertBox.style.display = "none", 2000);
}

function sendToWhatsApp() {
  const resultText = document.getElementById("result").innerText;
  if (!resultText.trim()) {
    alert("–ù–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ –≤ WhatsApp");
    return;
  }
  
  // Encode text for WhatsApp URL
  const encodedText = encodeURIComponent(resultText);
  const whatsappUrl = `https://wa.me/?text=${encodedText}`;
  
  // Open WhatsApp in new tab/window
  window.open(whatsappUrl, '_blank');
}

function sendInputToWhatsApp() {
  const inputText = document.getElementById("inputText").value;
  if (!inputText.trim()) {
    alert("–ù–µ—Ç —Ç–µ–∫—Å—Ç–∞ –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ –≤ WhatsApp");
    return;
  }
  
  // Encode text for WhatsApp URL
  const encodedText = encodeURIComponent(inputText);
  const whatsappUrl = `https://wa.me/?text=${encodedText}`;
  
  // Open WhatsApp in new tab/window
  window.open(whatsappUrl, '_blank');
}

function autoResizeTextarea(element) {
  element.style.height = 'auto';
  const minHeight = 60; // minimum 2 lines
  const maxHeight = 300; // maximum height
  const scrollHeight = element.scrollHeight;
  
  if (scrollHeight > minHeight) {
    element.style.height = Math.min(scrollHeight, maxHeight) + 'px';
  } else {
    element.style.height = minHeight + 'px';
  }
}

function autoResizeResultField(element) {
  // Reset height to calculate proper scroll height
  element.style.height = 'auto';
  const minHeight = 60; // minimum 2 lines
  const maxHeight = 300; // maximum height
  
  // Calculate required height based on content
  const scrollHeight = element.scrollHeight;
  
  if (scrollHeight > minHeight) {
    element.style.height = Math.min(scrollHeight, maxHeight) + 'px';
  } else {
    element.style.height = minHeight + 'px';
  }
  
  // Show scrollbar only if content exceeds max height
  if (scrollHeight > maxHeight) {
    element.style.overflowY = 'auto';
  } else {
    element.style.overflowY = 'hidden';
  }
}

function clearInput() {
  const textarea = document.getElementById("inputText");
  const resultBox = document.getElementById("result");
  textarea.value = "";
  resultBox.innerText = "";
  // Reset both fields height
  autoResizeTextarea(textarea);
  autoResizeResultField(resultBox);
}
// Initialize auto-resize and direction detection on page load
document.addEventListener('DOMContentLoaded', function() {
  const textarea = document.getElementById('inputText');
  const resultBox = document.getElementById('result');
  autoResizeTextarea(textarea);
  autoResizeResultField(resultBox);
  detectAndSetDirection(textarea);
  detectAndSetDirection(resultBox);
});

</script>

</body>
</html>
